#!/usr/bin/env python3
"""
Example script demonstrating how to interpret Mitsubishi PLK-A0804F sewing patterns

This script shows how to use the pattern parser to extract meaningful information
from the sewing machine patterns and interpret the different types of commands.
"""

from mitsubishi_pattern_parser import MitsubishiPatternParser, CommandType
import os

def interpret_pattern(filename):
    """Interpret a single pattern file and provide human-readable output."""
    parser = MitsubishiPatternParser()
    filepath = os.path.join("Patterns", filename)

    if not os.path.exists(filepath):
        print(f"Error: Pattern file {filename} not found!")
        return

    # Parse the pattern
    commands = parser.parse_file(filepath)
    analysis = parser.analyze_pattern_motion(filepath)

    print(f"\n=== PATTERN INTERPRETATION: {filename} ===")
    print(f"File size: {os.path.getsize(filepath)} bytes")
    print(f"Total commands: {len(commands)}")

    # Print summary statistics
    print(f"\nPattern Statistics:")
    print(f"  Stitch points: {analysis['stitch_points']}")
    print(f"  Movement commands: {analysis['movement_commands']}")
    print(f"  Speed changes: {analysis['speed_changes']}")
    print(f"  Function calls: {analysis['function_calls']}")
    print(f"  Estimated path length: {analysis['path_length']:.1f} units")

    # Print coordinate range
    x_range = analysis['coordinate_range']['x']
    y_range = analysis['coordinate_range']['y']
    print(f"  Working area: X={x_range[0]} to {x_range[1]}, Y={y_range[0]} to {y_range[1]}")
    print(f"  Dimensions: {x_range[1]-x_range[0]} x {y_range[1]-y_range[0]} units")

    # Show detailed interpretation of first 20 commands
    print(f"\nDetailed Command Interpretation (first 20 commands):")
    for i, cmd in enumerate(commands[:20]):
        if cmd.command_type == CommandType.POINT:
            print(f"  {i+1:2d}. STITCH at position ({cmd.x}, {cmd.y})")
        elif cmd.command_type == CommandType.LINEAR_MOVE:
            print(f"  {i+1:2d}. MOVE to position ({cmd.x}, {cmd.y})")
        elif cmd.command_type == CommandType.CIRCULAR:
            print(f"  {i+1:2d}. CIRCULAR motion to ({cmd.x}, {cmd.y})")
        elif cmd.command_type == CommandType.ARC:
            print(f"  {i+1:2d}. ARC command with parameters {cmd.parameters}")
        elif cmd.command_type == CommandType.CURVE:
            print(f"  {i+1:2d}. CURVE command with parameters {cmd.parameters}")
        elif cmd.command_type == CommandType.SPEED:
            print(f"  {i+1:2d}. SPEED setting: {cmd.parameters}")
        elif cmd.command_type == CommandType.FUNCTION:
            print(f"  {i+1:2d}. FUNCTION call: {cmd.parameters}")
        elif cmd.command_type == CommandType.SEPARATOR:
            print(f"  {i+1:2d}. PATTERN SECTION SEPARATOR")
        else:
            print(f"  {i+1:2d}. UNKNOWN command: {cmd.parameters}")

    if len(commands) > 20:
        print(f"  ... and {len(commands) - 20} more commands")

def generate_gcode_like_output(filename, output_file):
    """Generate a G-code-like representation of the pattern for visualization."""
    parser = MitsubishiPatternParser()
    filepath = os.path.join("Patterns", filename)

    commands = parser.parse_file(filepath)

    with open(output_file, 'w') as f:
        f.write(f"; G-code-like output for Mitsubishi pattern: {filename}\n")
        f.write(f"; Generated by Mitsubishi Pattern Parser\n")
        f.write(f"; Total commands: {len(commands)}\n\n")

        f.write("G90 ; Absolute positioning\n")
        f.write("G21 ; Units in millimeters\n\n")

        current_x, current_y = 0, 0

        for i, cmd in enumerate(commands):
            if cmd.command_type == CommandType.POINT:
                # Convert to reasonable scale (divide by ~100 to get mm-like units)
                x_mm = cmd.x / 100.0
                y_mm = cmd.y / 100.0
                f.write(f"G1 X{x_mm:.2f} Y{y_mm:.2f} ; Stitch point\n")
                current_x, current_y = x_mm, y_mm

            elif cmd.command_type == CommandType.LINEAR_MOVE:
                x_mm = cmd.x / 100.0
                y_mm = cmd.y / 100.0
                f.write(f"G0 X{x_mm:.2f} Y{y_mm:.2f} ; Move to position\n")
                current_x, current_y = x_mm, y_mm

            elif cmd.command_type == CommandType.CIRCULAR:
                x_mm = cmd.x / 100.0
                y_mm = cmd.y / 100.0
                f.write(f"G2 X{x_mm:.2f} Y{y_mm:.2f} ; Circular motion\n")
                current_x, current_y = x_mm, y_mm

            elif cmd.command_type == CommandType.SPEED:
                f.write(f"F{cmd.parameters[1] * 10} ; Speed change\n")

            elif cmd.command_type == CommandType.FUNCTION:
                f.write(f"M{cmd.parameters[0]} ; Function call\n")

            elif cmd.command_type == CommandType.SEPARATOR:
                f.write(f"; --- Pattern section separator ---\n")

        f.write("\nM30 ; End of program\n")

def main():
    """Demonstrate pattern interpretation with examples."""
    print("Mitsubishi PLK-A0804F Pattern Interpreter")
    print("=" * 50)

    # List available patterns
    patterns_dir = "Patterns"
    if not os.path.exists(patterns_dir):
        print(f"Error: {patterns_dir} directory not found!")
        return

    pattern_files = [f for f in os.listdir(patterns_dir)
                    if f.endswith(('.100', '.101', '.102', '.103', '.105', '.106', '.107', '.109', '.114', '.118'))]

    # Interpret a few example patterns
    example_patterns = ['NEW.109', '05PF.100', 'NEW.102']

    for pattern in example_patterns:
        if pattern in pattern_files:
            interpret_pattern(pattern)

            # Generate G-code-like output
            gcode_file = f"{pattern}_gcode.txt"
            generate_gcode_like_output(pattern, gcode_file)
            print(f"  G-code-like output saved to: {gcode_file}")
        else:
            print(f"Pattern {pattern} not found in available files")

    print(f"\nAll available patterns: {', '.join(pattern_files)}")
    print("\nTo interpret a specific pattern, use:")
    print("  python pattern_interpreter_example.py")

if __name__ == "__main__":
    main()